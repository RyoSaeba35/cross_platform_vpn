package com.example.cross_platform_vpn

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Intent
import android.content.pm.PackageManager
import android.net.VpnService
import android.os.Build
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.os.ParcelFileDescriptor
import android.util.Log
import androidx.core.app.NotificationCompat
import io.nekohasekai.libbox.Libbox
import io.nekohasekai.libbox.BoxService as LibboxService
import io.nekohasekai.libbox.TunOptions
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

class MyVpnService : VpnService(), io.nekohasekai.libbox.PlatformInterface {

    companion object {
        private const val TAG = "MyVpnService"
        private const val NOTIFICATION_ID = 1
        private const val CHANNEL_ID = "vpn_channel"
        var isRunning = false
    }

    private var boxService: LibboxService? = null
    private var fileDescriptor: ParcelFileDescriptor? = null
    private val mainHandler = Handler(Looper.getMainLooper())

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "Service created")
        createNotificationChannel()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(TAG, "onStartCommand: action=${intent?.action}")

        when (intent?.action) {
            "STOP_VPN" -> {
                stopVpnService()
                return START_NOT_STICKY
            }
            else -> {
                if (!isRunning) startVpnService()
                return START_STICKY
            }
        }
    }

    private fun startVpnService() {
        Log.d(TAG, "Starting VPN service")
        val notification = createNotification("Connected", "VPN is active")
        startForeground(NOTIFICATION_ID, notification)

        Thread {
            try {
                val config = """
                {
                    "log": { "level": "info", "timestamp": true },
                    "dns": {
                        "servers": [
                            { "tag": "dns-cloudflare", "address": "1.1.1.1", "detour": "direct" }
                        ],
                        "rules": [{ "outbound": "direct", "server": "dns-cloudflare" }]
                    },
                    "inbounds": [
                        {
                            "type": "tun",
                            "tag": "tun-in",
                            "interface_name": "tun0",
                            "inet4_address": "172.19.0.1/30",
                            "mtu": 9000,
                            "auto_route": true,
                            "strict_route": false,
                            "stack": "system",
                            "sniff": true
                        }
                    ],
                    "outbounds": [
                        { "type": "direct", "tag": "direct" },
                        { "type": "dns", "tag": "dns-out" },
                        { "type": "block", "tag": "block" }
                    ],
                    "route": {
                        "rules": [{ "protocol": "dns", "outbound": "dns-out" }],
                        "final": "direct",
                        "auto_detect_interface": true
                    }
                }
                """.trimIndent()

                Log.d(TAG, "Starting sing-box service from thread: ${Thread.currentThread().name}")
                Libbox.setMemoryLimit(true)

                val service = Libbox.newService(config, this)
                service.start()

                boxService = service
                isRunning = true
                Log.d(TAG, "✅ VPN started successfully")

            } catch (e: Exception) {
                Log.e(TAG, "❌ Failed to start VPN", e)
                stopSelf()
            }
        }.start()
    }

    private fun stopVpnService() {
        Log.d(TAG, "Stopping VPN service")
        try {
            fileDescriptor?.close()
            fileDescriptor = null
            boxService?.close()
            boxService = null
            isRunning = false
            stopForeground(STOP_FOREGROUND_REMOVE)
            stopSelf()
        } catch (e: Exception) {
            Log.e(TAG, "Error stopping VPN", e)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "Service destroyed")
        isRunning = false
    }

    override fun onRevoke() {
        super.onRevoke()
        Log.d(TAG, "VPN permission revoked")
        stopVpnService()
    }

    override fun onBind(intent: Intent?): IBinder? = super.onBind(intent)

    // =============================
    // PlatformInterface Implementation
    // =============================

    override fun usePlatformAutoDetectInterfaceControl(): Boolean = true
    override fun autoDetectInterfaceControl(fd: Int) { protect(fd) }

    override fun openTun(options: TunOptions): Int {
        if (Looper.myLooper() == Looper.getMainLooper()) return openTunInternal(options)

        var resultFd: Int? = null
        var exception: Exception? = null
        val latch = CountDownLatch(1)
        mainHandler.post {
            try { resultFd = openTunInternal(options) }
            catch (e: Exception) { exception = e }
            finally { latch.countDown() }
        }
        if (!latch.await(5, TimeUnit.SECONDS)) throw Exception("Timeout waiting for TUN creation")
        exception?.let { throw it }
        return resultFd ?: throw Exception("Failed to get TUN fd")
    }

    private fun openTunInternal(options: TunOptions): Int {
        if (prepare(this) != null) throw Exception("VPN permission not granted")
        val builder = Builder().setSession("VulcainVPN").setMtu(options.mtu.toInt())
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) builder.setMetered(false)

        // IPv4
        val inet4 = options.inet4Address
        while (inet4.hasNext()) {
            val addr = inet4.next()
            builder.addAddress(addr.address(), addr.prefix().toInt())
            Log.d(TAG, "Added IPv4: ${addr.address()}/${addr.prefix()}")
        }

        // IPv6
        val inet6 = options.inet6Address
        while (inet6.hasNext()) {
            val addr = inet6.next()
            builder.addAddress(addr.address(), addr.prefix().toInt())
            Log.d(TAG, "Added IPv6: ${addr.address()}/${addr.prefix()}")
        }

        if (options.autoRoute) {
            builder.addDnsServer(options.dnsServerAddress.value)
            builder.addRoute("0.0.0.0", 0)
            Log.d(TAG, "Added route: 0.0.0.0/0, DNS: ${options.dnsServerAddress.value}")
        }

        val pfd = builder.establish() ?: throw Exception("Failed to establish VPN")
        fileDescriptor = pfd
        Log.d(TAG, "✅ TUN established with fd: ${pfd.fd}")
        return pfd.fd
    }

    fun protectSocket(socketFd: Int) {
        try {
            protect(socketFd)
            Log.d(TAG, "Socket fd $socketFd protected from VPN routing")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to protect socket", e)
        }
    }

    // Return null for LocalDNSTransport to avoid compilation errors
    override fun localDNSTransport(): io.nekohasekai.libbox.LocalDNSTransport? = null

    override fun writeLog(message: String) { Log.d(TAG, "libbox: $message") }
    override fun useProcFS(): Boolean = Build.VERSION.SDK_INT < Build.VERSION_CODES.Q
    override fun findConnectionOwner(ipProtocol: Int, sourceAddress: String, sourcePort: Int, destinationAddress: String, destinationPort: Int): Int = -1
    override fun packageNameByUid(uid: Int): String = packageManager.getPackagesForUid(uid)?.first() ?: "unknown"
    override fun uidByPackageName(packageName: String): Int =
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
                packageManager.getPackageUid(packageName, PackageManager.PackageInfoFlags.of(0))
            else
                @Suppress("DEPRECATION") packageManager.getApplicationInfo(packageName, 0).uid
        } catch (_: PackageManager.NameNotFoundException) { -1 }

    override fun startDefaultInterfaceMonitor(listener: io.nekohasekai.libbox.InterfaceUpdateListener) {}
    override fun closeDefaultInterfaceMonitor(listener: io.nekohasekai.libbox.InterfaceUpdateListener) {}
    override fun getInterfaces(): io.nekohasekai.libbox.NetworkInterfaceIterator =
        object : io.nekohasekai.libbox.NetworkInterfaceIterator { override fun hasNext(): Boolean = false; override fun next(): io.nekohasekai.libbox.NetworkInterface? = null }
    override fun underNetworkExtension(): Boolean = false
    override fun includeAllNetworks(): Boolean = false
    override fun clearDNSCache() {}
    override fun readWIFIState(): io.nekohasekai.libbox.WIFIState? = null
    override fun systemCertificates(): io.nekohasekai.libbox.StringIterator =
        object : io.nekohasekai.libbox.StringIterator { override fun len(): Int = 0; override fun hasNext(): Boolean = false; override fun next(): String? = null }
    override fun sendNotification(notification: io.nekohasekai.libbox.Notification) {}

    // =============================
    // Notifications
    // =============================
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(CHANNEL_ID, "VPN Service", NotificationManager.IMPORTANCE_LOW)
            getSystemService(NotificationManager::class.java).createNotificationChannel(channel)
        }
    }

    private fun createNotification(title: String, message: String) =
        NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle(title)
            .setContentText(message)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setOngoing(true)
            .setContentIntent(
                PendingIntent.getActivity(this, 0, Intent(this, MainActivity::class.java), PendingIntent.FLAG_IMMUTABLE)
            ).build()
}
