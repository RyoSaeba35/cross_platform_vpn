package com.example.cross_platform_vpn

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Intent
import android.content.pm.PackageManager
import android.net.VpnService
import android.os.Build
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.os.ParcelFileDescriptor
import android.util.Log
import androidx.core.app.NotificationCompat
import io.nekohasekai.libbox.Libbox
import io.nekohasekai.libbox.BoxService as LibboxService
import io.nekohasekai.libbox.TunOptions
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

class MyVpnService : VpnService(), io.nekohasekai.libbox.PlatformInterface {

    companion object {
        private const val TAG = "MyVpnService"
        private const val NOTIFICATION_ID = 1
        private const val CHANNEL_ID = "vpn_channel"
        var isRunning = false
    }

    private var boxService: LibboxService? = null
    private var fileDescriptor: ParcelFileDescriptor? = null
    private val mainHandler = Handler(Looper.getMainLooper())

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "Service created")
        createNotificationChannel()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(TAG, "onStartCommand: action=${intent?.action}")

        when (intent?.action) {
            "STOP_VPN" -> {
                stopVpnService()
                return START_NOT_STICKY
            }
            else -> {
                if (!isRunning) {
                    startVpnService()
                }
                return START_STICKY
            }
        }
    }

    private fun startVpnService() {
        Log.d(TAG, "Starting VPN service")

        val notification = createNotification("Connected", "VPN is active")
        startForeground(NOTIFICATION_ID, notification)

        // Start sing-box in a BACKGROUND thread
        Thread {
            try {
                val config = """
                {
                    "log": {
                        "level": "info",
                        "timestamp": true
                    },
                    "dns": {
                        "servers": [
                            {
                                "tag": "dns-remote",
                                "address": "https://1.1.1.1/dns-query",
                                "detour": "direct"
                            },
                            {
                                "tag": "dns-local",
                                "address": "local",
                                "detour": "direct"
                            }
                        ],
                        "rules": [
                            {
                                "outbound": "any",
                                "server": "dns-local"
                            }
                        ]
                    },
                    "inbounds": [
                        {
                            "type": "tun",
                            "tag": "tun-in",
                            "interface_name": "tun0",
                            "inet4_address": "172.19.0.1/30",
                            "mtu": 9000,
                            "auto_route": true,
                            "strict_route": false,
                            "stack": "system",
                            "sniff": true
                        }
                    ],
                    "outbounds": [
                        { "type": "direct", "tag": "direct" },
                        { "type": "dns", "tag": "dns-out" },
                        { "type": "block", "tag": "block" }
                    ],
                    "route": {
                        "rules": [
                            { "protocol": "dns", "outbound": "dns-out" }
                        ],
                        "final": "direct",
                        "auto_detect_interface": true
                    }
                }
                """.trimIndent()

                Log.d(TAG, "Starting sing-box service from thread: ${Thread.currentThread().name}")
                Libbox.setMemoryLimit(true)

                val service = Libbox.newService(config, this)
                service.start()  // Now this will call openTun() from a background thread

                boxService = service
                isRunning = true

                Log.d(TAG, "âœ… VPN started successfully")

            } catch (e: Exception) {
                Log.e(TAG, "âŒ Failed to start VPN", e)
                e.printStackTrace()
                stopSelf()
            }
        }.start()  // â† Start the thread
    }

    private fun stopVpnService() {
        Log.d(TAG, "Stopping VPN service")

        try {
            fileDescriptor?.close()
            fileDescriptor = null

            boxService?.close()
            boxService = null

            isRunning = false

            stopForeground(STOP_FOREGROUND_REMOVE)
            stopSelf()

        } catch (e: Exception) {
            Log.e(TAG, "Error stopping VPN", e)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "Service destroyed")
        isRunning = false
    }

    override fun onRevoke() {
        super.onRevoke()
        Log.d(TAG, "VPN permission revoked")
        stopVpnService()
    }

    override fun onBind(intent: Intent?): IBinder? {
        return super.onBind(intent)
    }

    // ============================================================
    // PlatformInterface Implementation
    // ============================================================

    override fun usePlatformAutoDetectInterfaceControl(): Boolean = true

    override fun autoDetectInterfaceControl(fd: Int) {
        protect(fd)
    }

    override fun openTun(options: TunOptions): Int {
        Log.d(TAG, "ðŸ”µ openTun called from thread: ${Thread.currentThread().name}")

        // Check if we're already on the main thread
        if (Looper.myLooper() == Looper.getMainLooper()) {
            Log.d(TAG, "ðŸŸ¢ Already on main thread, executing directly")
            return openTunInternal(options)
        }

        // We're on a background thread, post to main and wait
        Log.d(TAG, "ðŸ”µ On background thread, posting to main")
        var resultFd: Int? = null
        var resultException: Exception? = null
        val latch = CountDownLatch(1)

        mainHandler.post {
            try {
                resultFd = openTunInternal(options)
            } catch (e: Exception) {
                resultException = e
            } finally {
                latch.countDown()
            }
        }

        if (!latch.await(5, TimeUnit.SECONDS)) {
            throw Exception("Timeout waiting for TUN creation")
        }

        resultException?.let { throw it }
        return resultFd ?: throw Exception("Failed to get TUN fd")
    }

    private fun openTunInternal(options: TunOptions): Int {
        Log.d(TAG, "ðŸŸ¢ openTunInternal running on thread: ${Thread.currentThread().name}")

        if (prepare(this) != null) {
            throw Exception("VPN permission not granted")
        }

        val builder = Builder()
            .setSession("VulcainVPN")
            .setMtu(options.mtu.toInt())

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            builder.setMetered(false)
        }

        // IPv4
        val inet4Address = options.inet4Address
        while (inet4Address.hasNext()) {
            val address = inet4Address.next()
            builder.addAddress(address.address(), address.prefix().toInt())
            Log.d(TAG, "Added IPv4: ${address.address()}/${address.prefix()}")
        }

        // IPv6
        val inet6Address = options.inet6Address
        while (inet6Address.hasNext()) {
            val address = inet6Address.next()
            builder.addAddress(address.address(), address.prefix().toInt())
            Log.d(TAG, "Added IPv6: ${address.address()}/${address.prefix()}")
        }

        if (options.autoRoute) {
            builder.addDnsServer(options.dnsServerAddress.value)
            Log.d(TAG, "DNS: ${options.dnsServerAddress.value}")

            builder.addRoute("0.0.0.0", 0)
            Log.d(TAG, "Added route: 0.0.0.0/0")
        }

        val pfd = builder.establish()
            ?: throw Exception("Failed to establish VPN")

        fileDescriptor = pfd
        Log.d(TAG, "âœ… TUN established with fd: ${pfd.fd}")

        return pfd.fd
    }

    override fun writeLog(message: String) {
        Log.d(TAG, "libbox: $message")
    }

    override fun useProcFS(): Boolean =
        Build.VERSION.SDK_INT < Build.VERSION_CODES.Q

    override fun findConnectionOwner(
        ipProtocol: Int,
        sourceAddress: String,
        sourcePort: Int,
        destinationAddress: String,
        destinationPort: Int
    ): Int = -1

    override fun packageNameByUid(uid: Int): String {
        val packages = packageManager.getPackagesForUid(uid)
        if (packages.isNullOrEmpty()) throw Exception("Package not found")
        return packages[0]
    }

    override fun uidByPackageName(packageName: String): Int {
        return try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                packageManager.getPackageUid(
                    packageName,
                    PackageManager.PackageInfoFlags.of(0)
                )
            } else {
                @Suppress("DEPRECATION")
                packageManager.getApplicationInfo(packageName, 0).uid
            }
        } catch (e: PackageManager.NameNotFoundException) {
            throw Exception("Package not found")
        }
    }

    override fun startDefaultInterfaceMonitor(listener: io.nekohasekai.libbox.InterfaceUpdateListener) {}
    override fun closeDefaultInterfaceMonitor(listener: io.nekohasekai.libbox.InterfaceUpdateListener) {}

    override fun getInterfaces(): io.nekohasekai.libbox.NetworkInterfaceIterator {
        return object : io.nekohasekai.libbox.NetworkInterfaceIterator {
            override fun hasNext(): Boolean = false
            override fun next(): io.nekohasekai.libbox.NetworkInterface? = null
        }
    }

    override fun underNetworkExtension(): Boolean = false
    override fun includeAllNetworks(): Boolean = false
    override fun clearDNSCache() {}
    override fun readWIFIState(): io.nekohasekai.libbox.WIFIState? = null
    override fun localDNSTransport(): io.nekohasekai.libbox.LocalDNSTransport? = null

    override fun systemCertificates(): io.nekohasekai.libbox.StringIterator {
        return object : io.nekohasekai.libbox.StringIterator {
            override fun len(): Int = 0
            override fun hasNext(): Boolean = false
            override fun next(): String? = null
        }
    }

    override fun sendNotification(notification: io.nekohasekai.libbox.Notification) {}

    // ============================================================
    // Notification
    // ============================================================

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "VPN Service",
                NotificationManager.IMPORTANCE_LOW
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(channel)
        }
    }

    private fun createNotification(title: String, message: String) =
        NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle(title)
            .setContentText(message)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setOngoing(true)
            .setContentIntent(
                PendingIntent.getActivity(
                    this,
                    0,
                    Intent(this, MainActivity::class.java),
                    PendingIntent.FLAG_IMMUTABLE
                )
            )
            .build()
}
